# Purpose: Configuration file for jupyterhub wrapper scripts (jh_startjob, jh_killjob, ...). This file will be sourced by wrapper scripts starting with jh_*
# Info: In case of a change no service has to be restarted, because the configuration file is re-read when the wrapper scripts are started.

######## MAINTENANCE MODE #######
is_cluster_in_maintenance=false

# Only following user can start a job if maintenance is active
maintenance_only_user="mwi"
##################################

######## GENERAL PROJECT INFORMATION ########
scratch_dir=/scratch/hpc-lco-jupyter 
external_hub_url="http://127.0.0.1:8083/hub/api"
############################################

####### WORKLOAD MANAGER CONFIGURATION #######	
# If you do not need a filter (pipe) just type `cat` in it. 
cmd_run_job=(sbatch --parsable)
cmd_run_job_debug=(sbatch --parsable)
# cmd_run_job_filter will be applied on cmd_run_job and cmd_run_job_debug
cmd_run_job_filter=(cat)

cmd_kill_job=(scancel)

cmd_job_owner=(squeue -ho %.j -j)
cmd_job_owner_filter=(cat)

cmd_job_batchfile=(squeue -ho %.o -j)
cmd_job_batchfile_filter=(cat)

# The output of cmd_job_state should only cotain the job state
cmd_job_state=(squeue -ho %.T -j)
cmd_job_state_filter=(cat)

cmd_job_get_mapped_node=(squeue -ho %.B -j)
cmd_job_get_mapped_node_filter=(cat)

cluster_job_is_running=(RUNNING COMPLETING)
cluster_job_is_stopped=(COMPLETED)
cluster_job_is_planned=(PLANNED PLANNING)

job_environment_job_id="$SLURM_JOB_ID"
##############################################

####### SSH TUNNEL CONFIGURATION #######
ssh_tunnel_api=true
ssh_tunnel_api_port=8083
ssh_tunnel_user_jh=tunnelbot
ssh_jh_ip=194.13.83.158
ssh_priv_key=$(cat ~/.ssh/id_rsa)

# Location of user home directories (can be changed, but why?)
creating_user_homes=false
home_dir=$scratch_dir/HOME_DIRECTORIES
user_home_dir=$home_dir/$JUPYTERHUB_USER/
user_log_directory=$user_home_dir/JupyterHub-Log/

# SINGULARITY OPTIONS
# syntax: --bind "SOURCE:DEST:OPTS" (COMMA SEPERATED)
use_singularity=true
singularity_bind_fix="$scratch_dir/jh_batchspawner_singleuser_replace:/opt/batchspawner/batchspawner/singleuser.py:ro,$scratch_dir/jh_starttunnel:/opt/.jh_starttunnel:ro"
singularity_bind_extra=""
singularity_bind="$singularity_bind_fix,$singularity_bind_extra"

singularity_no_mount=""
singularity_home_dir=""
singularity_extra_args=""

# Size of overlay image for singularity and user space (Megabytes)
# That means that the user has $overlay_size MB space, to configure his environment
overlay_size=2048
overlay_location=$home_dir/$JUPYTERHUB_USER/overlay.img
create_overlay_cmd=(dd if=/dev/zero of=$overlay_location bs=1M count=$overlay_size)
create_ext3_overlay_cmd=($scratch_dir/e2fsprogs/e2fsprogs-217c0bdf17899c0f79b73f76feeadd6d55863180/misc/mke2fs -F -q -t ext3 -d $scratch_dir/overlay_root/ $overlay_location)

# set which container directory should start for a specific note type (e.g. compute or gpu node)
container_to_start_compute=$scratch_dir/SINGULARITY/jupyterhub_hpc.sif
container_to_start_gpu=$scratch_dir/SINGULARITY/jupyterhub_hpc_gpu.sif

# enable debug mode
# more output at jhlog 
enable_debug_mode=false

# enable logging in $log_dir directory
enable_logging=true
log_dir=$scratch_dir/log

# if $log_dir does not exists, create it
[[ ! -d $log_dir ]] && [[ $enable_logging ]] && mkdir -p $log_dir

# singularity version that will be used to start container
cmd_load_singularity=(module load singularity)

# WebDAV
enable_webdav=false
webdav_command=
webdav_mount_dir=
webdav_mount_dir_container=

# syntax e.g. : create_log_entry "WARNING" "message content"
# Logging Function

logging_save_date_fmt="+%d%m%Y" 

function create_log_entry () {

	if $enable_logging; then
		current_date=$(date $logging_save_date_fmt)
		if [[ ! -f $log_dir/$current_date ]]; then 
			touch $log_dir/$current_date
		fi

		if [[ $1 == "INFO" ]]; then
			# Green
			logfmt="\e[32m["$1"]\e[39m[$(date)]: "$2""
			echo -e $logfmt >> $log_dir/$current_date
		elif [[ $1 == "DEBUG" ]]; then
			if [[ $enable_debug_mode == true ]]; then
				# Cyan
				logfmt="\e[36m["$1"]\e[39m[$(date)]: "$2""
				echo -e $logfmt >> $log_dir/$current_date
			fi
		elif [[ $1 == "WARNING" ]]; then
			# Light Yellow
			logfmt="\e[93m["$1"]\e[39m[$(date)]: "$2""
			echo -e $logfmt >> $log_dir/$current_date
		elif [[ $1 == "ERROR" ]]; then
			# Red
			logfmt="\e[31m["$1"]\e[39m[$(date)]: "$2""
			echo -e $logfmt >> $log_dir/$current_date
		else
			logfmt="["$1"][$(date)]: "$2""
			echo -e $logfmt >> $log_dir/$current_date
		fi
	fi
}
